C++里面的virtual关键字可以用虚函数声明，也可以用于虚继承。上一篇博客讲到了《虚函数》，这篇博客就讲虚继承。

首先来看为什么需要虚继承。C++里面继承关系中有个很有名的继承结构，菱形继承，如下图所示

普通继承，派生类包含了基类所有的非static成员。如果采用普通继承，在上图的iostream类中，实际上会存在两个ios基类。这样会带来很多问题，首先最简单的是空间浪费，iostream类中存在两个相同的ios类。更严重的是调用基类中的函数时，存在二义性，当iostream调用ios的成员函数时，编译器无法知道是调用istream还是ostream中的ios。

{图片}


C++的解决方案就是虚拟继承(virtual Inheritance)。 在虚拟继承下，只有一个共享的基类子对象被继承，而无论该基类在派生层次中出现多少次。共享的基类子对象被称为虚拟基类（virtual base class）。在虚拟继承下，基类子对象的复制及由此而引起的二义性都被消除了。

先来看对比的例子
inherentance.cc
virtual_inherentance.cc

## 构造的烦恼

由虚假继承引发的第一个问题是虚拟基类的构造，例如上面的例子中，构造iostream时，构造了istream和ostream两个基类，如果是虚继承关系，那么只有一个ios虚拟基类，那么谁来构造ios呢？

普通继承关系，基类由派生类构造。虚继承下，虚基类的构造由<em>最终派生类</em>显示调用，即iostream负责构造ios类, 中间类的构造函数将会被抑制，无法完成虚拟基类的构造。
看一个例子
constructor.cc
例子中，虽然bottom显示调用了middle1和middle2的构造函数，但是top的构造却不是有这两个中间类完成的, 因为top的成员name的值为“top”，实际上是由最终派生类bottom调用了top的默认构造函数`top()`。

要想完成虚基类top的构造，必须由最终派生类调用对应的虚基类构造函数。

constructor1.cc

在上面的例子中，bottom和bottom1都显示调用了top的构造函数，但前者没有调用了中间类的默认构造函数，后者调用了构造虚基类的构造函数，但结果对于虚基类的构造，都是由最终派生类构造的。

上面是一个中间类构造函数定义方式的好例子，当middle1和middle2做为最终派生类的时候，那么使用带参数的构造函数，做为中间类时，就声明一个为protected的默认构造函数，它仅仅完成类自身的构造和非虚拟继承的基类构造，最终派生类也不需要显示地构造中间类。

## 构造的顺序

普通继承是按照声明顺序进行构造的，虚继承由于先要进行虚基类的构造，再进行中间类的构造，所有构造顺序是：按照声明顺序构造虚基类，再按照声明顺序构造中间类和普通基类。

constructor_seq.cc
constructor_seq1.cc
上面这个两个例子中可以看出top_b的构造顺序是不一样的。第一个例子中，它放到了middle1和middle2后面构造，但在第二个例子中将它声明为了虚基类，它就放到了middle1和middle2前面构造了。

## 什么时候使用虚继承
这是否意味着，我们应该尽可能地以虚拟方式派生我们的基类，以便层次结构中后续的派生类可能会需要虚拟继承，是这样吗？不！我们强烈反对，那样做对性能的影响会很严重（而且增加了后续类派生的复杂性）。

那么，我们从不应该使用虚拟继承吗？不是，在实践中几乎所有成功使用虚拟继承的例子中，凡是需要虚拟继承的整个层次结构子树，如iostream 库或Panda 子树，都是由同一个人或项ç®设计组一次设计完成的。

一般地，除非虚拟继承为一个眼前的设计问题提供了解决方案，否则建议不要使用它。

## 虚拟基类成员的可视性

派生类Panda 从它的两个基类所继承而来的成员可被分为以下三类：

1 虚拟基类实例，它们没有被中间类改写，可以直接调用。

2 存在一个中间类，改写了基类的成员，那么最终类使用这个被改写了的成员.

3 存在二个或二个以上的基类，重载了虚基类的成员，那么最终派生类，必须重载这个成员。  

先看下面这个例子

members.cc

由例子可以看出，上面三点分别对应了printA, printB, printC三个函数

如果不在bottom中重载printC，那么编译是会报错。


## 虚继承的实现原理

虚继承的实现是通过一个虚继承表实现的。
