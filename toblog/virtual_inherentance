C++里面的virtual关键字可以用虚函数声明，也可以用于虚继承。上一篇博客讲到了《虚函数》，这篇博客就讲虚继承。

首先来看为什么需要虚继承。C++里面继承关系中有个很有名的继承结构，菱形继承，如下图所示

普通继承，派生类包含了基类所有的非static成员。如果采用普通继承，在上图的iostream类中，实际上会存在两个ios基类。这样会带来很多问题，首先最简单的是空间浪费，iostream类中存在两个相同的ios类。更严重的是调用基类中的函数时，存在二义性，当iostream调用ios的成员函数时，编译器无法知道是调用istream还是ostream中的ios。

C++的解决方案就是虚拟继承(virtual Inheritance)。 在虚拟继承下，只有一个共享的基类子对象被继承，而无论该基类在派生层次中出现多少次。共享的基类子对象被称为虚拟基类（virtual base class）。在虚拟继承下，基类子对象的复制及由此而引起的二义性都被消除了。

先来看对比的例子
inherentance.cc
virtual_inherentance.cc

## 构造的烦恼

## 构造的顺序

## 效率问题

## 什么时候使用虚继承
这是否意味着，我们应该尽可能地以虚拟方式派生我们的基类，以便层次结构中后续的派生类可能会需要虚拟继承，是这样吗？不！我们强烈反对，那样做对性能的影响会很严重（而且增加了后续类派生的复杂性）。

那么，我们从不应该使用虚拟继承吗？不是，在实践中几乎所有成功使用虚拟继承的例子中，凡是需要虚拟继承的整个层次结构子树，如iostream 库或Panda 子树，都是由同一个人或项ç®设计组一次设计完成的。

一般地，除非虚拟继承为一个眼前的设计问题提供了解决方案，否则建议不要使用它。

## 虚拟基类成员的可视性

派生类Panda 从它的两个基类所继承而来的成员可被分为以下三类：

1 ZooAnimal 虚拟基类实例，如name()和family_name()，它们没有被Bear 和Raccoon改写。

2 继承自Raccoon、属于ZooAnimal 虚拟基类的onExhibit()实例，以及Bear 定义的、被改写了的onExhibit()实例。

3 继承自ZooAnimal、分别被Bear 和Raccoon 特化了的print()实例。

对于这些继承得到的成员，哪些可以在Panda 类域中被直接地、无二义地访é®？在非虚拟派生下，答案是没有，所有非限定修饰的引用都是二义的。在虚拟派生下，第1 项和第2项的所有成员都可以被直接地、无二义地访问。


当两个以上的成员实例分别通过不同的派生路径被继承（不但适用于成员函数，也适用于数据成员和联套类型），并且它们都代表了相同的虚拟基类成员时，则不存在二义性，因为它们共亭了该成员的单个实例（第1 项）。如果一个代表虚拟基类的成员，而另一个是后续派生çAutocomplpopOnPopupPost±»的成员，则也不会有二义性（特化的派生类实例的优先级高于共享的虚拟基类实例[第2 项]）。但是，如果它们都代表后续派生类的实例，则直接访问该成员就是二义的。最好的解决办法是在派生类中给出一个改写的实例（第3 项）。


